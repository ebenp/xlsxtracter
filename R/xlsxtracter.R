#' Convert xlsx references to a dataframe

#' This function converts a column letter to number
#'
#' @param ref letter for reference
#' @return number
#' @importFrom stats setNames
#'
letter_num <- function(ref) {
  #named list of alphabetical letter and number
  col <- setNames(seq(1, 26), toupper(letters[1:26]))
  return(as.numeric(col[[ref]]))
}

#' This function loads a xlsx file and extracts the passed list to a dataframe
#'
#' @param infile Path to the input xlsx file
#' @param colrow List of header name to use, columns, rows, startrow,
#' row interval
#' @param sheet Optional sheet name
#' @return A data frame
#' @export
#' @importFrom utils tail
xlsxtractor <- function(infile, colrow, sheet = "Sheet1"){

  # read in the file
  d1 <- openxlsx::read.xlsx(infile, sheet)

  # slice to starting row
  startrow <- colrow[[5]]
  d1 <- d1[(startrow-2):length(d1[,1]), ]

  # header
  # make sure header and columns are the same length
  stopifnot(length(colrow[[1]]) == length((colrow[[2]])))
  # make sure the uniqueness is the same
  stopifnot(length(unique(colrow[[1]])) == length(unique((colrow[[2]]))))

  # grab the header if checks have passed
  header <- colrow[[1]]

  # determine column numbers
  col <- sapply(colrow[[2]], letter_num, USE.NAMES = F)

  # start row
  s <- as.numeric(colrow[[3]]) - startrow

  # end row. Add 1 to correctly capture the user input last row.
  e <- as.numeric(colrow[[4]]) - startrow + 1

  rows <- seq(s, e)
  # repeat
  rows <- seq(s, e, by = colrow[[6]])

  if (!(e == tail(rows, n=1))) {
  message("Warning: the last row generated by repetition
            does not match the user set row.","Generated row: ",
                                         tail(rows, n=1) + startrow,
          ". User input: ", e + startrow)
  }

  # create dataframe and set header names
  d1 <- data.frame(d1[rows,col])
  names(d1) <- header

  # return sliced dataframe
  return(d1)
}
